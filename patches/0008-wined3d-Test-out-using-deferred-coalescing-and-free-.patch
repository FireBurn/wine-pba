From 8d0b5ad03cd3c2bd57f1b04b98c95fa923b025e4 Mon Sep 17 00:00:00 2001
From: Andrew Comminos <andrew@comminos.com>
Date: Wed, 28 Feb 2018 20:23:11 -0800
Subject: [PATCH 8/8] wined3d: Test out using deferred coalescing and free
 lists for the PBA.

---
 dlls/wined3d/buffer_heap.c     | 261 +++++++++++++++++++++++++++++------------
 dlls/wined3d/device.c          |  16 ++-
 dlls/wined3d/wined3d_private.h |  14 ++-
 3 files changed, 206 insertions(+), 85 deletions(-)

diff --git a/dlls/wined3d/buffer_heap.c b/dlls/wined3d/buffer_heap.c
index f4af1b93b9..6e359af941 100644
--- a/dlls/wined3d/buffer_heap.c
+++ b/dlls/wined3d/buffer_heap.c
@@ -27,24 +27,24 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 
 struct wined3d_buffer_heap_element
 {
-    struct wine_rb_entry entry;
     struct wined3d_map_range range;
 
+    // rbtree data
+    struct wine_rb_entry entry;
+    BOOL in_tree;
+
     // Binned free list positions
     struct wined3d_buffer_heap_element *next;
     struct wined3d_buffer_heap_element *prev;
-};
-
-struct wined3d_buffer_heap_range
-{
-    struct wined3d_map_range range;
 
-    struct wined3d_buffer_heap_range *next;
+    // Coalesce queue positions
+    struct wined3d_buffer_heap_element *coalesce_next;
+    struct wined3d_buffer_heap_element *coalesce_prev;
 };
 
 struct wined3d_buffer_heap_fenced_element
 {
-    struct wined3d_buffer_heap_range *ranges;
+    struct wined3d_buffer_heap_element *ranges;
     struct wined3d_fence *fence;
 
     struct wined3d_buffer_heap_fenced_element *next;
@@ -58,8 +58,11 @@ static struct wined3d_buffer_heap_element* element_new(GLsizei offset, GLsizei s
         return NULL;
     elem->range.offset = offset;
     elem->range.size = size;
+    elem->in_tree = FALSE;
     elem->prev = NULL;
     elem->next = NULL;
+    elem->coalesce_prev = NULL;
+    elem->coalesce_next = NULL;
     return elem;
 }
 
@@ -86,9 +89,8 @@ static int element_bin(struct wined3d_buffer_heap_element *elem)
     return min(WINED3D_BUFFER_HEAP_BINS - 1, bitwise_log2_floor(elem->range.size));
 }
 
-// Inserts and element into the free tree and its bin.
-// Does not coalesce.
-static void element_insert_free(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
+// Inserts an element into the appropriate free list bin.
+static void element_insert_free_bin(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
 {
     int bin = element_bin(elem);
 
@@ -98,15 +100,37 @@ static void element_insert_free(struct wined3d_buffer_heap *heap, struct wined3d
         heap->free_bins[bin]->prev = elem;
     heap->free_bins[bin] = elem;
 
+    TRACE("Inserted allocation at %p of size %lld into bin %d\n", elem->range.offset, elem->range.size, bin);
+}
+
+// Inserts an elemnet into the free tree. Does not perform coalescing.
+static void element_insert_free_tree(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
+{
+    if (elem->in_tree)
+    {
+        FIXME("Element %p already in free tree, ignoring.\n", elem);
+        return;
+    }
     if (wine_rb_put(&heap->free_tree, &elem->range.offset, &elem->entry) == -1)
     {
         ERR("Failed to insert element into free tree.\n");
+        return;
     }
+    TRACE("Inserted allocation at %p of size %lld into free tree\n", elem->range.offset, elem->range.size);
+    elem->in_tree = TRUE;
+}
 
-    TRACE("Inserted allocation at %p of size %lld into bin %d\n", elem->range.offset, elem->range.size, bin);
+// Defers an element for coalescing.
+static void element_defer_coalesce(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
+{
+    elem->coalesce_next = heap->deferred_coalesce_head;
+    elem->coalesce_prev = NULL;
+    if (heap->deferred_coalesce_head)
+        heap->deferred_coalesce_head->coalesce_prev = elem;
+    heap->deferred_coalesce_head = elem;
 }
 
-// Removes an element from the free tree and its bin.
+// Removes an element from the free tree, its bin, and the coalesce list.
 static void element_remove_free(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
 {
     int bin = element_bin(elem);
@@ -123,12 +147,29 @@ static void element_remove_free(struct wined3d_buffer_heap *heap, struct wined3d
     elem->prev = NULL;
     elem->next = NULL;
 
-    wine_rb_remove(&heap->free_tree, &elem->entry);
+    // No need to coalesce a buffer that's been reallocated quickly.
+    if (elem->coalesce_prev)
+        elem->coalesce_prev->coalesce_next = elem->coalesce_next;
+
+    if (heap->deferred_coalesce_head == elem)
+        heap->deferred_coalesce_head = elem->coalesce_next;
+
+    if (elem->coalesce_next)
+        elem->coalesce_next->coalesce_prev = elem->coalesce_prev;
+
+    elem->coalesce_prev = NULL;
+    elem->coalesce_next = NULL;
+
+    if (elem->in_tree)
+    {
+        wine_rb_remove(&heap->free_tree, &elem->entry);
+        elem->in_tree = FALSE;
+    }
 
     TRACE("Freed allocation at %p of size %lld from bin %d\n", elem->range.offset, elem->range.size, bin);
 }
 
-static struct wined3d_buffer_heap_fenced_element* fenced_element_new(struct wined3d_buffer_heap_range *ranges, struct wined3d_fence* fence)
+static struct wined3d_buffer_heap_fenced_element* fenced_element_new(struct wined3d_buffer_heap_element *ranges, struct wined3d_fence* fence)
 {
     struct wined3d_buffer_heap_fenced_element* elem;
     elem = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_buffer_heap_fenced_element));
@@ -163,6 +204,11 @@ HRESULT wined3d_buffer_heap_create(struct wined3d_context *context, GLsizeiptr s
 
     struct wined3d_buffer_heap *object;
 
+    if ((alignment & (alignment - 1)) != 0)
+    {
+        return E_FAIL;
+    }
+
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
     {
         return E_OUTOFMEMORY;
@@ -196,11 +242,13 @@ HRESULT wined3d_buffer_heap_create(struct wined3d_context *context, GLsizeiptr s
     object->alignment = alignment;
     object->pending_fenced_bytes = 0;
     object->pending_fenced_head = NULL;
-    object->pending_fenced_threshold_bytes = size / 4; // FIXME(acomminos): make this externally declared
+    // FIXME(acomminos): make this externally declared
+    object->pending_fenced_threshold_bytes = 64 * 1024 * 1024;
     InitializeCriticalSection(&object->temp_lock);
 
     initial_elem = element_new(0, size);
-    element_insert_free(object, initial_elem);
+    // Don't bother adding the initial allocation to the coalescing tree.
+    element_insert_free_bin(object, initial_elem);
 
     *buffer_heap = object;
 
@@ -217,16 +265,20 @@ HRESULT wined3d_buffer_heap_destroy(struct wined3d_buffer_heap *heap, struct win
 HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr size, struct wined3d_map_range *out_range)
 {
     int initial_bin;
+
     EnterCriticalSection(&heap->temp_lock);
 
-    // Round to the nearest power of two to reduce fragmentation.
-    size = 1ULL << bitwise_log2_ceil(size);
+    // TODO(acomminos): trigger deferred allocator based on fragmentation level
 
-    // Round up the size to a multiple of the heap's alignment.
+    // Align size values where possible.
     if (heap->alignment)
         size += heap->alignment - (size % heap->alignment);
 
-    // TODO(acomminos): use bitwise arithmetic instead
+    // After alignment, reduce fragmentation by rounding to next power of two.
+    // If the alignment is a power of two (which it should be), this should be
+    // no problem.
+    size = 1 << bitwise_log2_ceil(size);
+
     initial_bin = min(WINED3D_BUFFER_HEAP_BINS - 1, bitwise_log2_ceil(size));
 
     for (int i = initial_bin; i < WINED3D_BUFFER_HEAP_BINS; i++)
@@ -247,7 +299,8 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
             if (remaining_range.size > 0)
             {
                 elem->range = remaining_range;
-                element_insert_free(heap, elem);
+                element_insert_free_bin(heap, elem);
+                element_defer_coalesce(heap, elem);
             }
             else
             {
@@ -259,15 +312,27 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
         }
     }
 
+    // Attempt to coalesce blocks until an allocation of the requested size is
+    // available.
+    GLsizei coalesced_size;
+    while (SUCCEEDED(wined3d_buffer_heap_deferred_coalesce(heap, &coalesced_size)) && coalesced_size > 0)
+    {
+        FIXME_(d3d_perf)("Forcing coalesce, not enough free space in buffer heap.\n");
+        if (coalesced_size >= size)
+        {
+            LeaveCriticalSection(&heap->temp_lock);
+            return wined3d_buffer_heap_alloc(heap, size, out_range);
+        }
+    }
+
     LeaveCriticalSection(&heap->temp_lock);
+
     return WINED3DERR_OUTOFVIDEOMEMORY;
 }
 
 HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3d_map_range range)
 {
     struct wined3d_buffer_heap_element *elem = element_new(range.offset, range.size);
-    struct wined3d_map_range coalesced_range = range;
-    struct wine_rb_entry *entry;
     HRESULT hr;
 
     if (!elem)
@@ -275,53 +340,9 @@ HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3
 
     EnterCriticalSection(&heap->temp_lock);
 
-    // TODO(acomminos): implement lower_bound, upper_bound.
-    //                  we don't have to allocate a new elem here, this sentry
-    //                  is just so I can get this proof of concept out the door.
-
-    if (wine_rb_put(&heap->free_tree, &elem->range.offset, &elem->entry) == -1)
-    {
-        LeaveCriticalSection(&heap->temp_lock);
-        HeapFree(GetProcessHeap(), 0, elem);
-        return E_FAIL;
-    }
-
-    // Coalesce left.
-    entry = wine_rb_prev(&elem->entry);
-    if (entry)
-    {
-        TRACE("Coalesced left.\n");
-        struct wined3d_buffer_heap_element *left_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
-        if (left_elem->range.offset + left_elem->range.size == coalesced_range.offset)
-        {
-            coalesced_range.offset = left_elem->range.offset;
-            coalesced_range.size = coalesced_range.size + left_elem->range.size;
-
-            element_remove_free(heap, left_elem);
-            HeapFree(GetProcessHeap(), 0, left_elem);
-        }
-    }
-
-    // Coalesce right.
-    entry = wine_rb_next(&elem->entry);
-    if (entry)
-    {
-        TRACE("Coalesced right.\n");
-        struct wined3d_buffer_heap_element *right_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
-        if (elem->range.offset + elem->range.size == right_elem->range.offset)
-        {
-            coalesced_range.size += right_elem->range.size;
-
-            element_remove_free(heap, right_elem);
-            HeapFree(GetProcessHeap(), 0, right_elem);
-        }
-    }
-
-    wine_rb_remove(&heap->free_tree, &elem->entry);
-
-    // Update with coalesced range.
-    elem->range = coalesced_range;
-    element_insert_free(heap, elem);
+    // Only insert the element into a free bin, coalescing will occur later.
+    element_insert_free_bin(heap, elem);
+    element_defer_coalesce(heap, elem);
 
     LeaveCriticalSection(&heap->temp_lock);
 
@@ -330,8 +351,9 @@ HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3
 
 HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct wined3d_device *device, struct wined3d_map_range range)
 {
-    struct wined3d_buffer_heap_range *elem = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_buffer_heap_range));
-    elem->range = range;
+    struct wined3d_buffer_heap_element *elem = element_new(range.offset, range.size);
+    if (heap->pending_fenced_head)
+        heap->pending_fenced_head->prev = elem;
     elem->next = heap->pending_fenced_head;
     heap->pending_fenced_head = elem;
 
@@ -390,15 +412,22 @@ HRESULT wined3d_buffer_heap_cs_poll_fences(struct wined3d_buffer_heap *heap, str
         case WINED3D_FENCE_NOT_STARTED:
             {
                 TRACE_(d3d_perf)("Freed fence group.\n");
-                struct wined3d_buffer_heap_range *range_elem = elem->ranges;
-                // FIXME(acomminos): this might take a while. incrementally do this?
+
+                // Add freed elements to free bins, coalesce queue.
+                struct wined3d_buffer_heap_element *range_elem = elem->ranges;
+
+                EnterCriticalSection(&heap->temp_lock);
                 while (range_elem)
                 {
-                    struct wined3d_buffer_heap_range *next = range_elem->next;
-                    wined3d_buffer_heap_free(heap, range_elem->range);
-                    HeapFree(GetProcessHeap(), 0, range_elem);
+                    struct wined3d_buffer_heap_element *next = range_elem->next;
+
+                    // Add to free bin for immediate allocation.
+                    element_insert_free_bin(heap, range_elem);
+                    element_defer_coalesce(heap, range_elem);
+
                     range_elem = next;
                 }
+                LeaveCriticalSection(&heap->temp_lock);
 
                 wined3d_fence_destroy(elem->fence);
 
@@ -413,3 +442,79 @@ HRESULT wined3d_buffer_heap_cs_poll_fences(struct wined3d_buffer_heap *heap, str
 
     return WINED3D_OK;
 }
+
+HRESULT wined3d_buffer_heap_deferred_coalesce(struct wined3d_buffer_heap *heap, GLsizei *coalesced_size)
+{
+    struct wined3d_buffer_heap_element *elem;
+    struct wine_rb_entry *entry;
+    struct wined3d_map_range coalesced_range;
+
+    EnterCriticalSection(&heap->temp_lock);
+
+    elem = heap->deferred_coalesce_head;
+    if (!elem)
+    {
+        LeaveCriticalSection(&heap->temp_lock);
+        *coalesced_size = 0; // List is empty
+        return WINED3D_OK;
+    }
+
+    // Remove element from free list, we may change its size or offset.
+    element_remove_free(heap, elem);
+    coalesced_range = elem->range;
+
+    // TODO(acomminos): implement lower_bound, upper_bound.
+    //                  we don't have to allocate a new elem here, this sentry
+    //                  is just so I can get this proof of concept out the door.
+
+    if (wine_rb_put(&heap->free_tree, &elem->range.offset, &elem->entry) == -1)
+    {
+        LeaveCriticalSection(&heap->temp_lock);
+        return E_FAIL;
+    }
+
+    // Coalesce left.
+    entry = wine_rb_prev(&elem->entry);
+    if (entry)
+    {
+        TRACE("Coalesced left.\n");
+        struct wined3d_buffer_heap_element *left_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
+        if (left_elem->range.offset + left_elem->range.size == coalesced_range.offset)
+        {
+            coalesced_range.offset = left_elem->range.offset;
+            coalesced_range.size = coalesced_range.size + left_elem->range.size;
+
+            element_remove_free(heap, left_elem);
+            HeapFree(GetProcessHeap(), 0, left_elem);
+        }
+    }
+
+    // Coalesce right.
+    entry = wine_rb_next(&elem->entry);
+    if (entry)
+    {
+        TRACE("Coalesced right.\n");
+        struct wined3d_buffer_heap_element *right_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
+        if (elem->range.offset + elem->range.size == right_elem->range.offset)
+        {
+            coalesced_range.size += right_elem->range.size;
+
+            element_remove_free(heap, right_elem);
+            HeapFree(GetProcessHeap(), 0, right_elem);
+        }
+    }
+
+    wine_rb_remove(&heap->free_tree, &elem->entry);
+
+    // Update with coalesced range.
+    elem->range = coalesced_range;
+
+    if (coalesced_size)
+        *coalesced_size = coalesced_range.size;
+
+    element_insert_free_bin(heap, elem);
+    element_insert_free_tree(heap, elem);
+
+    LeaveCriticalSection(&heap->temp_lock);
+    return WINED3D_OK;
+}
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index bdab83b935..9f300ca572 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -848,26 +848,32 @@ static void destroy_default_samplers(struct wined3d_device *device, struct wined
 /* Context activation is done by the caller. */
 static void create_buffer_heap(struct wined3d_device *device, struct wined3d_context *context)
 {
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     // TODO(acomminos): check if ARB_buffer_storage is supported, first-
     //                  possibly make wined3d_buffer_heap_create fail.
-    // TODO(acomminos): 512MB is sane for geometry, maybe not for PBO.
-    const GLsizeiptr HBO_SIZE = min(512000000, device->adapter->vram_bytes / 4);
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    // TODO(acomminos): kill this magic number. perhaps base on vram.
+    GLsizeiptr geo_heap_size = 512 * 1024 * 1024;
+    GLsizeiptr cb_heap_size = 256 * 1024 * 1024;
 
     GLint ub_alignment;
     gl_info->gl_ops.gl.p_glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &ub_alignment);
 
+    // Align constant buffer heap size, in case GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT isn't a power of two (for some reason).
+    cb_heap_size -= cb_heap_size % ub_alignment;
+
     HRESULT hr;
-    if (FAILED(hr = wined3d_buffer_heap_create(context, HBO_SIZE, 0, TRUE, &device->wo_buffer_heap)))
+    if (FAILED(hr = wined3d_buffer_heap_create(context, geo_heap_size, 0, TRUE, &device->wo_buffer_heap)))
     {
         ERR("Failed to create write-only persistent buffer heap, hr %#x.\n", hr);
     }
 
     // TODO(acomminos): can likely use a way smaller heap for CBs by querying limits
-    if (FAILED(hr = wined3d_buffer_heap_create(context, HBO_SIZE, ub_alignment, TRUE, &device->cb_buffer_heap)))
+    if (FAILED(hr = wined3d_buffer_heap_create(context, cb_heap_size, ub_alignment, TRUE, &device->cb_buffer_heap)))
     {
         ERR("Failed to create persistent buffer heap for constant buffers, hr %#x.\n", hr);
     }
+
+    FIXME("Initialized wine-pba (geo_heap_size: %lld, cb_heap_size: %lld, ub_align: %d)\n", geo_heap_size, cb_heap_size, ub_alignment);
 }
 
 /* Context activation is done by the caller. */
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 14cad92f0f..77585ea1bf 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -3667,7 +3667,6 @@ enum wined3d_buffer_conversion_type
 
 struct wined3d_buffer_heap_element;
 struct wined3d_buffer_heap_fenced_element;
-struct wined3d_buffer_heap_range;
 
 // Number of power-of-two buckets to populate.
 #define WINED3D_BUFFER_HEAP_BINS 32
@@ -3684,10 +3683,15 @@ struct wined3d_buffer_heap
     struct wine_rb_tree free_tree; // Free regions keyed on their base address.
 
     // Elements that need to be fenced, but haven't reached the required size.
-    struct wined3d_buffer_heap_range *pending_fenced_head;
+    struct wined3d_buffer_heap_element *pending_fenced_head;
     GLsizeiptr pending_fenced_bytes; // Number of free bytes in the active fenced region.
     GLsizeiptr pending_fenced_threshold_bytes; // Number of bytes required before fencing.
 
+    // Elements that have yet to be inserted into the free tree for coalescing.
+    // Should be done only when the CS thread is idle, or under memory pressure.
+    // This is highly advantageous for handling rapid buffer reallocations.
+    struct wined3d_buffer_heap_element *deferred_coalesce_head;
+
     // List of sets of buffers behind a common fence, in FIFO order.
     struct wined3d_buffer_heap_fenced_element *fenced_head;
     struct wined3d_buffer_heap_fenced_element *fenced_tail;
@@ -3696,6 +3700,7 @@ struct wined3d_buffer_heap
 HRESULT wined3d_buffer_heap_create(struct wined3d_context *context, GLsizeiptr size, GLsizeiptr alignment, BOOL write_only, struct wined3d_buffer_heap **heap) DECLSPEC_HIDDEN;
 HRESULT wined3d_buffer_heap_destroy(struct wined3d_buffer_heap *heap, struct wined3d_context *context) DECLSPEC_HIDDEN;
 // Fetches a buffer from the heap of at least the given size.
+// Attempts to coalesce blocks under memory pressure.
 HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr size, struct wined3d_map_range* out_range) DECLSPEC_HIDDEN;
 // Immediately frees a heap-allocated buffer segment.
 HRESULT wined3d_buffer_heap_free(struct wined3d_buffer_heap *heap, struct wined3d_map_range range) DECLSPEC_HIDDEN;
@@ -3704,6 +3709,11 @@ HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct
 // Moves a buffers with a signaled fence from the fenced list to the free list.
 // Must be executed on the CS thread.
 HRESULT wined3d_buffer_heap_cs_poll_fences(struct wined3d_buffer_heap *heap, struct wined3d_device *device) DECLSPEC_HIDDEN;
+// Performs deferred coalescing of fenced buffers. To be called when the CS
+// thread is idle, or under memory pressure.
+// Outputs the size of the new coalesced region in `coalesced_size`, zero if
+// out of elements for coalescing.
+HRESULT wined3d_buffer_heap_deferred_coalesce(struct wined3d_buffer_heap *heap, GLsizei *coalesced_size) DECLSPEC_HIDDEN;
 
 struct wined3d_buffer
 {
-- 
2.16.2

