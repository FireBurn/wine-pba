From bb85f931410fa08d13405780292b6f323409fa92 Mon Sep 17 00:00:00 2001
From: Andrew Comminos <andrew@comminos.com>
Date: Sun, 4 Mar 2018 05:31:50 -0800
Subject: [PATCH 9/9] wined3d: Instantiate and mutate PBA free tree only during
 memory pressure.

---
 dlls/wined3d/buffer_heap.c     | 174 +++++++++++++++++------------------------
 dlls/wined3d/device.c          |   2 +-
 dlls/wined3d/wined3d_private.h |   6 +-
 3 files changed, 75 insertions(+), 107 deletions(-)

diff --git a/dlls/wined3d/buffer_heap.c b/dlls/wined3d/buffer_heap.c
index 4d90dcf861..510b506b5f 100644
--- a/dlls/wined3d/buffer_heap.c
+++ b/dlls/wined3d/buffer_heap.c
@@ -31,7 +31,6 @@ struct wined3d_buffer_heap_element
 
     // rbtree data
     struct wine_rb_entry entry;
-    BOOL in_tree;
 
     // Binned free list positions
     struct wined3d_buffer_heap_element *next;
@@ -54,7 +53,6 @@ static struct wined3d_buffer_heap_element* element_new(GLsizei offset, GLsizei s
         return NULL;
     elem->range.offset = offset;
     elem->range.size = size;
-    elem->in_tree = FALSE;
     return elem;
 }
 
@@ -98,23 +96,6 @@ static void element_insert_free_bin(struct wined3d_buffer_heap *heap, struct win
     TRACE("Inserted allocation at %p of size %lld into bin %d\n", elem->range.offset, elem->range.size, bin);
 }
 
-// Inserts an elemnet into the free tree. Does not perform coalescing.
-static void element_insert_free_tree(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
-{
-    if (elem->in_tree)
-    {
-        FIXME("Element %p already in free tree, ignoring.\n", elem);
-        return;
-    }
-    if (wine_rb_put(&heap->free_tree, &elem->range.offset, &elem->entry) == -1)
-    {
-        ERR("Failed to insert element into free tree.\n");
-        return;
-    }
-    TRACE("Inserted allocation at %p of size %lld into free tree\n", elem->range.offset, elem->range.size);
-    elem->in_tree = TRUE;
-}
-
 // Removes an element from the free tree, its bin, and the coalesce list.
 static void element_remove_free(struct wined3d_buffer_heap *heap, struct wined3d_buffer_heap_element *elem)
 {
@@ -135,12 +116,6 @@ static void element_remove_free(struct wined3d_buffer_heap *heap, struct wined3d
     elem->prev = NULL;
     elem->next = NULL;
 
-    if (elem->in_tree)
-    {
-        wine_rb_remove(&heap->free_tree, &elem->entry);
-        elem->in_tree = FALSE;
-    }
-
     TRACE("Freed allocation at %p of size %lld from bin %d\n", elem->range.offset, elem->range.size, bin);
 }
 
@@ -211,8 +186,6 @@ HRESULT wined3d_buffer_heap_create(struct wined3d_context *context, GLsizeiptr s
     }
     context_bind_bo(context, buffer_target, 0);
 
-    wine_rb_init(&object->free_tree, free_tree_compare);
-
     object->fenced_head = object->fenced_tail = NULL;
     object->alignment = alignment;
     // FIXME(acomminos): make this externally declared
@@ -289,18 +262,16 @@ HRESULT wined3d_buffer_heap_alloc(struct wined3d_buffer_heap *heap, GLsizeiptr s
 
     LeaveCriticalSection(&heap->temp_lock);
 
-    // Attempt to coalesce blocks until an allocation of the requested size is
-    // available.
-    GLsizei coalesced_size;
-    while (SUCCEEDED(wined3d_buffer_heap_deferred_coalesce(heap, &coalesced_size)))
+    FIXME_(d3d_perf)("Forcing coalesce, not enough free space in buffer heap.\n");
+    int num_coalesced;
+    if (SUCCEEDED(wined3d_buffer_heap_deferred_coalesce(heap, &num_coalesced)))
     {
-        FIXME_(d3d_perf)("Forcing coalesce, not enough free space in buffer heap.\n");
-        if (coalesced_size >= size)
-        {
+        if (num_coalesced > 0)
             return wined3d_buffer_heap_alloc(heap, size, out_range);
-        }
     }
 
+    FIXME_(d3d_perf)("Coalescing did not create new blocks, failing.\n");
+
     return WINED3DERR_OUTOFVIDEOMEMORY;
 }
 
@@ -436,101 +407,100 @@ HRESULT wined3d_buffer_heap_cs_poll_fences(struct wined3d_buffer_heap *heap, str
     return WINED3D_OK;
 }
 
-HRESULT wined3d_buffer_heap_deferred_coalesce(struct wined3d_buffer_heap *heap, GLsizei *coalesced_size)
+HRESULT wined3d_buffer_heap_deferred_coalesce(struct wined3d_buffer_heap *heap, int *coalesced_count)
 {
     struct wined3d_buffer_heap_element *elem = NULL;
+    struct wined3d_buffer_heap_element *next = NULL;
     struct wine_rb_entry *entry;
     struct wined3d_map_range coalesced_range;
 
-    // XXX(acomminos): is it always the best idea to coalesce by smallest
-    // chunks? these are the most likely to be useless.
+    struct wine_rb_tree free_tree;
+    int num_coalesced = 0;
+
+    wine_rb_init(&free_tree, free_tree_compare);
+
     EnterCriticalSection(&heap->temp_lock);
 
     // TODO(acomminos): on one hand, if there's a lot of elements in the list,
     // it's highly fragmented. on the other, we can potentially waste a decent
     // sum of time checking for uncoalesced bins.
-    for (int i = 0; i < WINED3D_BUFFER_HEAP_BINS && elem == NULL; i++)
+    for (int i = 0; i < WINED3D_BUFFER_HEAP_BINS; i++)
     {
-        struct wined3d_buffer_heap_element *next = heap->free_list.bins[i].head;
-        while (next)
+        elem = heap->free_list.bins[i].head;
+        while (elem)
         {
-            if (next->in_tree == FALSE)
+            // Insert a sentry. FIXME(acomminos): can skip this with traversal.
+            if (wine_rb_put(&free_tree, &elem->range.offset, &elem->entry) == -1)
             {
-                // Find the first element not in-tree.
-                elem = next;
-                break;
+                ERR("Failed to insert key %x in tree.\n", elem->range.offset);
+                elem = elem->next;
+                continue;
             }
-            next = next->next;
-        }
-    }
 
-    // TODO(acomminos): acquire a separate lock for the free tree here.
-    if (!elem)
-    {
-        ERR("Failed to find element to coalesce.\n");
-        LeaveCriticalSection(&heap->temp_lock);
-        return E_FAIL;
-    }
-    element_remove_free(heap, elem);
+            coalesced_range = elem->range;
 
-    // Remove element from free list, we may change its size or offset.
-    coalesced_range = elem->range;
+            // Coalesce right.
+            entry = wine_rb_next(&elem->entry);
+            if (entry)
+            {
+                TRACE("Coalesced right.\n");
+                struct wined3d_buffer_heap_element *right_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
+                if (elem->range.offset + elem->range.size == right_elem->range.offset)
+                {
+                    coalesced_range.size += right_elem->range.size;
 
-    // TODO(acomminos): implement lower_bound, upper_bound.
-    //                  we don't have to allocate a new elem here, this sentry
-    //                  is just so I can get this proof of concept out the door.
+                    wine_rb_remove(&free_tree, entry);
+                    element_remove_free(heap, right_elem);
+                    HeapFree(GetProcessHeap(), 0, right_elem);
 
-    if (wine_rb_put(&heap->free_tree, &elem->range.offset, &elem->entry) == -1)
-    {
-        LeaveCriticalSection(&heap->temp_lock);
-        return E_FAIL;
-    }
+                    num_coalesced++;
+                }
+            }
 
-    // Coalesce left.
-    entry = wine_rb_prev(&elem->entry);
-    if (entry)
-    {
-        TRACE("Coalesced left.\n");
-        struct wined3d_buffer_heap_element *left_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
-        if (left_elem->range.offset + left_elem->range.size == coalesced_range.offset)
-        {
-            coalesced_range.offset = left_elem->range.offset;
-            coalesced_range.size += left_elem->range.size;
+            // Coalesce left.
+            entry = wine_rb_prev(&elem->entry);
+            if (entry)
+            {
+                TRACE("Coalesced left.\n");
+                struct wined3d_buffer_heap_element *left_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
+                if (left_elem->range.offset + left_elem->range.size == coalesced_range.offset)
+                {
+                    coalesced_range.offset = left_elem->range.offset;
+                    coalesced_range.size += left_elem->range.size;
 
-            element_remove_free(heap, left_elem);
-            HeapFree(GetProcessHeap(), 0, left_elem);
-        }
-    }
+                    wine_rb_remove(&free_tree, entry);
+                    element_remove_free(heap, left_elem);
+                    HeapFree(GetProcessHeap(), 0, left_elem);
 
-    // Coalesce right.
-    entry = wine_rb_next(&elem->entry);
-    if (entry)
-    {
-        TRACE("Coalesced right.\n");
-        struct wined3d_buffer_heap_element *right_elem = WINE_RB_ENTRY_VALUE(entry, struct wined3d_buffer_heap_element, entry);
-        if (elem->range.offset + elem->range.size == right_elem->range.offset)
-        {
-            coalesced_range.size += right_elem->range.size;
+                    num_coalesced++;
+                }
+            }
 
-            element_remove_free(heap, right_elem);
-            HeapFree(GetProcessHeap(), 0, right_elem);
-        }
-    }
+            next = elem->next;
 
-    wine_rb_remove(&heap->free_tree, &elem->entry);
+            if (elem->range.size != coalesced_range.size)
+            {
+                FIXME_(d3d_perf)("Coalesced range from (%p, %ld) to (%p, %ld)\n", elem->range.offset, elem->range.size, coalesced_range.offset, coalesced_range.size);
 
-    if (coalesced_range.size > elem->range.size)
-        FIXME_(d3d_perf)("Coalesced out an extra %lld bytes\n", coalesced_range.size - elem->range.size);
+                wine_rb_remove(&free_tree, &elem->entry);
 
-    // Update with coalesced range.
-    elem->range = coalesced_range;
+                // Move to the correct free bin.
+                element_remove_free(heap, elem);
+                elem->range = coalesced_range;
+                element_insert_free_bin(heap, elem);
 
-    if (coalesced_size)
-        *coalesced_size = coalesced_range.size;
+                wine_rb_put(&free_tree, &elem->range.offset, &elem->entry);
+            }
 
-    element_insert_free_bin(heap, elem);
-    element_insert_free_tree(heap, elem);
+            elem = next;
+        }
+    }
 
     LeaveCriticalSection(&heap->temp_lock);
+
+    FIXME_(d3d_perf)("Performed %d coalesces.\n", num_coalesced);
+    if (coalesced_count)
+        *coalesced_count = num_coalesced;
+
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 9f300ca572..78641058a0 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -853,7 +853,7 @@ static void create_buffer_heap(struct wined3d_device *device, struct wined3d_con
     //                  possibly make wined3d_buffer_heap_create fail.
     // TODO(acomminos): kill this magic number. perhaps base on vram.
     GLsizeiptr geo_heap_size = 512 * 1024 * 1024;
-    GLsizeiptr cb_heap_size = 256 * 1024 * 1024;
+    GLsizeiptr cb_heap_size = 128 * 1024 * 1024;
 
     GLint ub_alignment;
     gl_info->gl_ops.gl.p_glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &ub_alignment);
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 3011609ee1..5bba3b7183 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -3691,7 +3691,6 @@ struct wined3d_buffer_heap
     CRITICAL_SECTION temp_lock; // Temporary lock while we implement the fenced free list.
 
     struct wined3d_buffer_heap_bin_set free_list;
-    struct wine_rb_tree free_tree; // Free regions keyed on their base address.
 
     // Elements that need to be fenced, but haven't reached the required size.
     struct wined3d_buffer_heap_bin_set pending_fenced_bins;
@@ -3717,9 +3716,8 @@ HRESULT wined3d_buffer_heap_free_fenced(struct wined3d_buffer_heap *heap, struct
 HRESULT wined3d_buffer_heap_cs_poll_fences(struct wined3d_buffer_heap *heap, struct wined3d_device *device) DECLSPEC_HIDDEN;
 // Performs deferred coalescing of fenced buffers. To be called when the CS
 // thread is idle, or under memory pressure.
-// Outputs the size of the new coalesced region in `coalesced_size`, or an error
-// if there are no remaining elements to be coalesced.
-HRESULT wined3d_buffer_heap_deferred_coalesce(struct wined3d_buffer_heap *heap, GLsizei *coalesced_size) DECLSPEC_HIDDEN;
+// Outputs the number of coalesced regions in `num_coalesced`.
+HRESULT wined3d_buffer_heap_deferred_coalesce(struct wined3d_buffer_heap *heap, int *num_coalesced) DECLSPEC_HIDDEN;
 
 struct wined3d_buffer
 {
-- 
2.16.2

